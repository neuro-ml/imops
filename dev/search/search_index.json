{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Imops","text":"<p>Efficient parallelizable algorithms for multidimensional arrays to speed up your data pipelines</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install imops  # default install with Cython backend\npip install imops[numba]  # additionally install Numba backend\n</code></pre>"},{"location":"#functions","title":"Functions","text":""},{"location":"#imops.radon.radon","title":"<code>imops.radon.radon</code>","text":"<p>Fast implementation of Radon transform. Adapted from scikit-image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>an array with at least 2 axes</p> required <code>axes</code> <code>Tuple[int, int]</code> <p>the axes in the <code>image</code> along which the Radon transform will be applied. The <code>image</code> shape along the <code>axes</code> must be of the same length</p> <code>None</code> <code>theta</code> <code>Union[int, Sequence[float]]</code> <p>the angles for which the Radon transform will be computed. If it is an integer - the angles will be evenly distributed between 0 and 180, <code>theta</code> values in total</p> <code>180</code> <code>return_fill</code> <code>bool</code> <p>whether to return the value that fills the image outside the circle working area</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to be used for parallel computation. By default - equals to the number of cpu cores</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>the execution backend. Currently only \"Cython\" is avaliable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sinogram</code> <code>np.ndarray</code> <p>the result of the Radon transform</p> <code>fill_value</code> <code>float</code> <p>the value that fills the image outside the circle working area. Returned only if <code>return_fill</code> is True</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sinogram = radon(image)  # 2d image\n&gt;&gt;&gt; sinogram, fill_value = radon(image, return_fill=True)  # 2d image with fill value\n&gt;&gt;&gt; sinogram = radon(image, axes=(-2, -1))  # nd image\n</code></pre>"},{"location":"#imops.radon.inverse_radon","title":"<code>imops.radon.inverse_radon</code>","text":"<p>Fast implementation of inverse Radon transform. Adapted from scikit-image.</p> <p>Parameters:</p> Name Type Description Default <code>sinogram</code> <code>np.ndarray</code> <p>an array with at least 2 axes</p> required <code>axes</code> <code>Tuple[int, int]</code> <p>the axes in the <code>image</code> along which the inverse Radon transform will be applied. The <code>image</code> shape along the <code>axes</code> must be of the same length</p> <code>None</code> <code>theta</code> <code>Union[int, Sequence[float]]</code> <p>the angles for which the inverse Radon transform will be computed. If it is an integer - the angles will be evenly distributed between 0 and 180, <code>theta</code> values in total</p> <code>180</code> <code>fill_value</code> <code>float</code> <p>the value that fills the image outside the circle working area. Can be returned by <code>radon</code></p> <code>0</code> <code>a</code> <code>float</code> <p>the first parameter of the sharpen filter</p> <code>0</code> <code>b</code> <code>float</code> <p>the second parameter of the sharpen filter</p> <code>1</code> <code>num_threads</code> <code>int</code> <p>the number of threads to be used for parallel computation. By default - equals to the number of cpu cores</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>the execution backend. Currently only \"Cython\" is avaliable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>image</code> <code>np.ndarray</code> <p>the result of the inverse Radon transform</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; image = inverse_radon(sinogram)  # 2d image\n&gt;&gt;&gt; image = inverse_radon(sinogram, fill_value=-1000)  # 2d image with fill value\n&gt;&gt;&gt; image = inverse_radon(sinogram, axes=(-2, -1))  # nd image\n</code></pre>"},{"location":"#imops.zoom.zoom","title":"<code>imops.zoom.zoom</code>","text":"<p>Rescale <code>x</code> according to <code>scale_factor</code> along the <code>axis</code>.</p> <p>Uses a fast parallelizable implementation for fp32 / fp64 inputs, ndim &lt;= 3 and order = 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>scale_factor</code> <code>AxesParams</code> <p>float or sequence of floats describing how to scale along axes</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which array will be scaled</p> <code>None</code> <code>order</code> <code>int</code> <p>order of interpolation</p> <code>1</code> <code>fill_value</code> <code>Union[float, Callable]</code> <p>value to fill past edges. If Callable (e.g. <code>numpy.min</code>) - <code>fill_value(x)</code> will be used</p> <code>0</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zoomed</code> <code>np.ndarray</code> <p>zoomed array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zoomed = zoom(x, 2, axis=[0, 1])  # 3d array\n&gt;&gt;&gt; zoomed = zoom(x, [1, 2, 3])  # different scales along each axes\n&gt;&gt;&gt; zoomed = zoom(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n</code></pre>"},{"location":"#imops.zoom.zoom_to_shape","title":"<code>imops.zoom.zoom_to_shape</code>","text":"<p>Rescale <code>x</code> to match <code>shape</code> along the <code>axis</code>.</p> <p>Uses a fast parallelizable implementation for fp32 / fp64 inputs, ndim &lt;= 3 and order = 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>shape</code> <code>AxesLike</code> <p>float or sequence of floats describing desired lengths along axes</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which array will be scaled</p> <code>None</code> <code>order</code> <code>int</code> <p>order of interpolation</p> <code>1</code> <code>fill_value</code> <code>Union[float, Callable]</code> <p>value to fill past edges. If Callable (e.g. <code>numpy.min</code>) - <code>fill_value(x)</code> will be used</p> <code>0</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zoomed</code> <code>np.ndarray</code> <p>zoomed array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zoomed = zoom_to_shape(x, [3, 4, 5])  # 3d array\n&gt;&gt;&gt; zoomed = zoom_to_shape(x, [6, 7], axis=[1, 2])  # zoom to shape along specified axes\n&gt;&gt;&gt; zoomed = zoom_to_shape(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n</code></pre>"},{"location":"#imops.pad.pad","title":"<code>imops.pad.pad</code>","text":"<p>Pad <code>x</code> according to <code>padding</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>array to pad</p> required <code>padding</code> <code>Union[AxesLike, Sequence[Sequence[int]]]</code> <p>if 2D array [[start_1, stop_1], ..., [start_n, stop_n]] - specifies individual padding for each axis from <code>axis</code>. The length of the array must either be equal to 1 or match the length of <code>axis</code>. If 1D array [val_1, ..., val_n] - same as [[val_1, val_1], ..., [val_n, val_n]]. If scalar (val) - same as [[val, val]]</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with, must be broadcastable to the resulting array. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; padded = pad(x, 2)  # pad 2 zeros on each side of each axes\n&gt;&gt;&gt; padded = pad(x, [1, 1], axis=(-1, -2))  # pad 1 zero on each side of last 2 axes\n</code></pre>"},{"location":"#imops.pad.pad_to_shape","title":"<code>imops.pad.pad_to_shape</code>","text":"<p>Pad <code>x</code> to match <code>shape</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>array to pad</p> required <code>shape</code> <code>AxesLike</code> <p>final shape</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with, must be broadcastable to the resulting array. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes. Remaining ratio of padding will be applied on the right sides</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; padded = pad_to_shape(x, [4, 5, 6])  # pad 3d array\n&gt;&gt;&gt; padded = pad_to_shape(x, [4, 5], axis=[0, 1], ratio=0)  # pad first 2 axes on the right\n</code></pre>"},{"location":"#imops.pad.pad_to_divisible","title":"<code>imops.pad.pad_to_divisible</code>","text":"<p>Pad <code>x</code> to be divisible by <code>divisor</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> required <code>divisor</code> <code>AxesLike</code> <p>float or sequence of floats an incoming array shape will be divisible by</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which the array will be padded. If None - the last <code>len(divisor)</code> axes are used</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes. Remaining ratio of padding will be applied on the right sides</p> <code>0.5</code> <code>remainder</code> <code>AxesLike</code> <p><code>x</code> will be padded such that its shape gives the remainder <code>remainder</code> when divided by <code>divisor</code></p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; padded = pad_to_divisible(x, 6)  # pad to shape [6, 6, 6]\n&gt;&gt;&gt; padded = pad_to_divisible(x, [4, 3], axis=[0, 1], ratio=1)  # pad first 2 axes on the left, shape - [4, 3, 4]\n&gt;&gt;&gt; padded = pad_to_divisible(x, 3, remainder=1)  # pad to shape [4, 4, 4]\n</code></pre>"}]}