{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Imops","text":"<p>Efficient parallelizable algorithms for multidimensional arrays to speed up your data pipelines</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install imops  # default install with Cython backend\npip install imops[numba]  # additionally install Numba backend\n</code></pre>"},{"location":"#functions","title":"Functions","text":""},{"location":"#imops.crop.crop_to_shape","title":"<code>imops.crop.crop_to_shape(x, shape, axis=None, ratio=0.5)</code>","text":"<p>Crop <code>x</code> to match <code>shape</code> along <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>shape</code> <code>AxesLike</code> <p>final shape</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of cropping to apply on the left sides of cropping axes. Remaining ratio of cropping will be applied on the right sides</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>cropped</code> <code>np.ndarray</code> <p>cropped array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; cropped = crop_to_shape(x, [1, 2, 3], ratio=0)  # crop to shape [1, 2, 3] from the right\n&gt;&gt;&gt; cropped = crop_to_shape(x, 2, axis=1, ratio=1)  # crop to shape [2, 2, 4] from the left\n&gt;&gt;&gt; cropped = crop_to_shape(x, [3, 4, 5])  # fail due to bigger resulting shape\n</code></pre> Source code in <code>imops/crop.py</code> <pre><code>def crop_to_shape(x: np.ndarray, shape: AxesLike, axis: AxesLike = None, ratio: AxesParams = 0.5) -&gt; np.ndarray:\n\"\"\"\n    Crop `x` to match `shape` along `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array\n    shape: AxesLike\n        final shape\n    axis: AxesLike\n        axis along which `x` will be padded\n    ratio: AxesParams\n        float or sequence of floats describing what proportion of cropping to apply on the left sides of cropping axes.\n        Remaining ratio of cropping will be applied on the right sides\n    Returns\n    -------\n    cropped: np.ndarray\n        cropped array\n    Examples\n    --------\n    &gt;&gt;&gt; x  # array of shape [2, 3, 4]\n    &gt;&gt;&gt; cropped = crop_to_shape(x, [1, 2, 3], ratio=0)  # crop to shape [1, 2, 3] from the right\n    &gt;&gt;&gt; cropped = crop_to_shape(x, 2, axis=1, ratio=1)  # crop to shape [2, 2, 4] from the left\n    &gt;&gt;&gt; cropped = crop_to_shape(x, [3, 4, 5])  # fail due to bigger resulting shape\n    \"\"\"\nx = np.asarray(x)\naxis, shape, ratio = broadcast_axis(axis, x.ndim, shape, ratio)\nold_shape, new_shape = np.array(x.shape), np.array(fill_by_indices(x.shape, shape, axis))\nif (old_shape &lt; new_shape).any():\nraise ValueError(f'The resulting shape cannot be greater than the original one: {old_shape} vs {new_shape}.')\nndim = len(x.shape)\nratio = fill_by_indices(np.zeros(ndim), ratio, axis)\nstart = ((old_shape - new_shape) * ratio).astype(int)\nreturn x[tuple(map(slice, start, start + new_shape))]\n</code></pre>"},{"location":"#imops.crop.crop_to_box","title":"<code>imops.crop.crop_to_box(x, box, axis=None, padding_values=None)</code>","text":"<p>Crop <code>x</code> according to <code>box</code> along <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>box</code> <code>np.ndarray</code> <p>array of shape (2, x.ndim or len(axis) if axis is passed) describing crop boundaries</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be cropped</p> <code>None</code> <code>padding_values</code> <code>AxesParams</code> <p>values to pad with if box exceeds the input's limits</p> <code>None</code> <p>Returns:</p> Name Type Description <code>cropped</code> <code>np.ndarray</code> <p>cropped array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; cropped = crop_to_box(x, np.array([[0, 0, 0], [1, 1, 1]]))  # crop to shape [1, 1, 1]\n&gt;&gt;&gt; cropped = crop_to_box(x, np.array([[0, 0, 0], [5, 5, 5]]))  # fail, box exceeds the input's limits\n&gt;&gt;&gt; cropped = crop_to_box(x, np.array([[0], [5]]), axis=0, padding_values=0)  # pad with 0-s to shape [5, 3, 4]\n</code></pre> Source code in <code>imops/crop.py</code> <pre><code>def crop_to_box(x: np.ndarray, box: np.ndarray, axis: AxesLike = None, padding_values: AxesParams = None) -&gt; np.ndarray:\n\"\"\"\n    Crop `x` according to `box` along `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array\n    box: np.ndarray\n        array of shape (2, x.ndim or len(axis) if axis is passed) describing crop boundaries\n    axis: AxesLike\n        axis along which `x` will be cropped\n    padding_values: AxesParams\n        values to pad with if box exceeds the input's limits\n    Returns\n    -------\n    cropped: np.ndarray\n        cropped array\n    Examples\n    --------\n    &gt;&gt;&gt; x  # array of shape [2, 3, 4]\n    &gt;&gt;&gt; cropped = crop_to_box(x, np.array([[0, 0, 0], [1, 1, 1]]))  # crop to shape [1, 1, 1]\n    &gt;&gt;&gt; cropped = crop_to_box(x, np.array([[0, 0, 0], [5, 5, 5]]))  # fail, box exceeds the input's limits\n    &gt;&gt;&gt; cropped = crop_to_box(x, np.array([[0], [5]]), axis=0, padding_values=0)  # pad with 0-s to shape [5, 3, 4]\n    \"\"\"\nx = np.asarray(x)\nstart, stop = box\naxis, start, stop = broadcast_axis(axis, x.ndim, start, stop)\nslice_start = np.maximum(start, 0)\nslice_stop = np.minimum(stop, np.array(x.shape)[list(axis)])\npadding = np.array([slice_start - start, stop - slice_stop], dtype=int).T\nif padding_values is None and padding.any():\nraise ValueError(f\"The box {box} exceeds the input's limits {x.shape}.\")\nslice_start = fill_by_indices(np.zeros(x.ndim, int), slice_start, axis)\nslice_stop = fill_by_indices(x.shape, slice_stop, axis)\nx = x[tuple(map(slice, slice_start, slice_stop))]\nif padding_values is not None and padding.any():\nx = pad(x, padding, axis, padding_values)\nreturn x\n</code></pre>"},{"location":"#imops.pad.pad","title":"<code>imops.pad.pad(x, padding, axis=None, padding_values=0)</code>","text":"<p>Pad <code>x</code> according to <code>padding</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array to pad</p> required <code>padding</code> <code>Union[AxesLike, Sequence[Sequence[int]]]</code> <p>if 2D array [[start_1, stop_1], ..., [start_n, stop_n]] - specifies individual padding for each axis from <code>axis</code>. The length of the array must either be equal to 1 or match the length of <code>axis</code>. If 1D array [val_1, ..., val_n] - same as [[val_1, val_1], ..., [val_n, val_n]]. If scalar (val) - same as [[val, val]]</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with, must be broadcastable to the resulting array. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; padded = pad(x, 2)  # pad 2 zeros on each side of each axes\n&gt;&gt;&gt; padded = pad(x, [1, 1], axis=(-1, -2))  # pad 1 zero on each side of last 2 axes\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def pad(\nx: np.ndarray,\npadding: Union[AxesLike, Sequence[Sequence[int]]],\naxis: AxesLike = None,\npadding_values: Union[AxesParams, Callable] = 0,\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` according to `padding` along the `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array to pad\n    padding: Union[AxesLike, Sequence[Sequence[int]]]\n        if 2D array [[start_1, stop_1], ..., [start_n, stop_n]] - specifies individual padding\n        for each axis from `axis`. The length of the array must either be equal to 1 or match the length of `axis`.\n        If 1D array [val_1, ..., val_n] - same as [[val_1, val_1], ..., [val_n, val_n]].\n        If scalar (val) - same as [[val, val]]\n    axis: AxesLike\n        axis along which `x` will be padded\n    padding_values: Union[AxesParams, Callable]\n        values to pad with, must be broadcastable to the resulting array.\n        If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; padded = pad(x, 2)  # pad 2 zeros on each side of each axes\n    &gt;&gt;&gt; padded = pad(x, [1, 1], axis=(-1, -2))  # pad 1 zero on each side of last 2 axes\n    \"\"\"\nx = np.asarray(x)\npadding = np.asarray(padding)\nif padding.ndim &lt; 2:\npadding = padding.reshape(-1, 1)\naxis = axis_from_dim(axis, x.ndim)\npadding = np.asarray(fill_by_indices(np.zeros((x.ndim, 2), dtype=int), np.atleast_2d(padding), axis))\nif (padding &lt; 0).any():\nraise ValueError(f'Padding must be non-negative: {padding.tolist()}.')\nif callable(padding_values):\npadding_values = padding_values(x)\nnew_shape = np.array(x.shape) + np.sum(padding, axis=1)\nnew_x = np.array(padding_values, dtype=x.dtype)\nnew_x = np.broadcast_to(new_x, new_shape).copy()\nstart = padding[:, 0]\nend = np.where(padding[:, 1] != 0, -padding[:, 1], None)\nnew_x[tuple(map(slice, start, end))] = x\nreturn new_x\n</code></pre>"},{"location":"#imops.pad.pad_to_shape","title":"<code>imops.pad.pad_to_shape(x, shape, axis=None, padding_values=0, ratio=0.5)</code>","text":"<p>Pad <code>x</code> to match <code>shape</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array to pad</p> required <code>shape</code> <code>AxesLike</code> <p>final shape</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with, must be broadcastable to the resulting array. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes. Remaining ratio of padding will be applied on the right sides</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; padded = pad_to_shape(x, [4, 5, 6])  # pad 3d array\n&gt;&gt;&gt; padded = pad_to_shape(x, [4, 5], axis=[0, 1], ratio=0)  # pad first 2 axes on the right\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def pad_to_shape(\nx: np.ndarray,\nshape: AxesLike,\naxis: AxesLike = None,\npadding_values: Union[AxesParams, Callable] = 0,\nratio: AxesParams = 0.5,\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` to match `shape` along the `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array to pad\n    shape: AxesLike\n        final shape\n    axis: AxesLike\n        axis along which `x` will be padded\n    padding_values: Union[AxesParams, Callable]\n        values to pad with, must be broadcastable to the resulting array.\n        If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    ratio: AxesParams\n        float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes.\n        Remaining ratio of padding will be applied on the right sides\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; padded = pad_to_shape(x, [4, 5, 6])  # pad 3d array\n    &gt;&gt;&gt; padded = pad_to_shape(x, [4, 5], axis=[0, 1], ratio=0)  # pad first 2 axes on the right\n    \"\"\"\nx = np.asarray(x)\naxis, shape, ratio = broadcast_axis(axis, x.ndim, shape, ratio)\nold_shape = np.array(x.shape)[list(axis)]\nif (old_shape &gt; shape).any():\nshape = fill_by_indices(x.shape, shape, axis)\nraise ValueError(f'The resulting shape cannot be smaller than the original: {x.shape} vs {shape}.')\ndelta = shape - old_shape\nstart = (delta * ratio).astype(int)\npadding = np.array((start, delta - start)).T.astype(int)\nreturn pad(x, padding, axis, padding_values=padding_values)\n</code></pre>"},{"location":"#imops.pad.pad_to_divisible","title":"<code>imops.pad.pad_to_divisible(x, divisor, axis=None, padding_values=0, ratio=0.5, remainder=0)</code>","text":"<p>Pad <code>x</code> to be divisible by <code>divisor</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array to pad</p> required <code>divisor</code> <code>AxesLike</code> <p>float or sequence of floats an incoming array shape will be divisible by</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which the array will be padded. If None - the last <code>len(divisor)</code> axes are used</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes. Remaining ratio of padding will be applied on the right sides</p> <code>0.5</code> <code>remainder</code> <code>AxesLike</code> <p><code>x</code> will be padded such that its shape gives the remainder <code>remainder</code> when divided by <code>divisor</code></p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; padded = pad_to_divisible(x, 6)  # pad to shape [6, 6, 6]\n&gt;&gt;&gt; padded = pad_to_divisible(x, [4, 3], axis=[0, 1], ratio=1)  # pad first 2 axes on the left, shape - [4, 3, 4]\n&gt;&gt;&gt; padded = pad_to_divisible(x, 3, remainder=1)  # pad to shape [4, 4, 4]\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def pad_to_divisible(\nx: np.ndarray,\ndivisor: AxesLike,\naxis: AxesLike = None,\npadding_values: Union[AxesParams, Callable] = 0,\nratio: AxesParams = 0.5,\nremainder: AxesLike = 0,\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` to be divisible by `divisor` along the `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array to pad\n    divisor: AxesLike\n        float or sequence of floats an incoming array shape will be divisible by\n    axis: AxesLike\n        axis along which the array will be padded. If None - the last `len(divisor)` axes are used\n    padding_values: Union[AxesParams, Callable]\n        values to pad with. If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    ratio: AxesParams\n        float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes.\n        Remaining ratio of padding will be applied on the right sides\n    remainder: AxesLike\n        `x` will be padded such that its shape gives the remainder `remainder` when divided by `divisor`\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; x  # array of shape [2, 3, 4]\n    &gt;&gt;&gt; padded = pad_to_divisible(x, 6)  # pad to shape [6, 6, 6]\n    &gt;&gt;&gt; padded = pad_to_divisible(x, [4, 3], axis=[0, 1], ratio=1)  # pad first 2 axes on the left, shape - [4, 3, 4]\n    &gt;&gt;&gt; padded = pad_to_divisible(x, 3, remainder=1)  # pad to shape [4, 4, 4]\n    \"\"\"\nx = np.asarray(x)\naxis = axis_from_dim(axis, x.ndim)\ndivisor, remainder, ratio = broadcast_to_axis(axis, divisor, remainder, ratio)\nassert np.all(remainder &gt;= 0)\nshape = np.maximum(np.array(x.shape)[list(axis)], remainder)\nreturn pad_to_shape(x, shape + (remainder - shape) % divisor, axis, padding_values, ratio)\n</code></pre>"},{"location":"#imops.pad.restore_crop","title":"<code>imops.pad.restore_crop(x, box, shape, padding_values=0)</code>","text":"<p>Pad <code>x</code> to match <code>shape</code>. The left padding is taken equal to <code>box</code>'s start.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array to pad</p> required <code>box</code> <code>np.ndarray</code> <p>array of shape (2, x.ndim) describing crop boundaries</p> required <code>shape</code> <code>AxesLike</code> <p>shape to restore crop to</p> required <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [2, 3, 4]]), [4, 4, 4])  # pad to shape [4, 4, 4]\n&gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [1, 1, 1]]), [4, 4, 4])  # fail, box is inconsistent with an array\n&gt;&gt;&gt; padded = restore_crop(x, np.array([[1, 2, 3], [3, 5, 7]]), [3, 5, 7])  # pad to shape [3, 5, 7]\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def restore_crop(\nx: np.ndarray, box: np.ndarray, shape: AxesLike, padding_values: Union[AxesParams, Callable] = 0\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` to match `shape`. The left padding is taken equal to `box`'s start.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array to pad\n    box: np.ndarray\n        array of shape (2, x.ndim) describing crop boundaries\n    shape: AxesLike\n        shape to restore crop to\n    padding_values: Union[AxesParams, Callable]\n        values to pad with. If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; x  # array of shape [2, 3, 4]\n    &gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [2, 3, 4]]), [4, 4, 4])  # pad to shape [4, 4, 4]\n    &gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [1, 1, 1]]), [4, 4, 4])  # fail, box is inconsistent with an array\n    &gt;&gt;&gt; padded = restore_crop(x, np.array([[1, 2, 3], [3, 5, 7]]), [3, 5, 7])  # pad to shape [3, 5, 7]\n    \"\"\"\nstart, stop = np.asarray(box)\nassert len(shape) == x.ndim\nassert len(start) == len(stop) == x.ndim\nx = np.asarray(x)\nif (stop &gt; shape).any() or (stop - start != x.shape).any():\nraise ValueError(\nf'The input array (of shape {x.shape}) was not obtained by cropping a '\nf'box {start, stop} from the shape {shape}.'\n)\npadding = np.array([start, shape - stop], dtype=int).T\nx = pad(x, padding, padding_values=padding_values)\nassert all(np.array(x.shape) == shape)\nreturn x\n</code></pre>"},{"location":"#imops.zoom.zoom","title":"<code>imops.zoom.zoom(x, scale_factor, axis=None, order=1, fill_value=0, num_threads=-1, backend=None)</code>","text":"<p>Rescale <code>x</code> according to <code>scale_factor</code> along the <code>axis</code>.</p> <p>Uses a fast parallelizable implementation for fp32 / fp64 (and int16-32-64 if order == 0) inputs, ndim &lt;= 4 and order = 0 or 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>scale_factor</code> <code>AxesParams</code> <p>float or sequence of floats describing how to scale along axes</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which array will be scaled</p> <code>None</code> <code>order</code> <code>int</code> <p>order of interpolation</p> <code>1</code> <code>fill_value</code> <code>Union[float, Callable]</code> <p>value to fill past edges. If Callable (e.g. <code>numpy.min</code>) - <code>fill_value(x)</code> will be used</p> <code>0</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zoomed</code> <code>np.ndarray</code> <p>zoomed array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zoomed = zoom(x, 2, axis=[0, 1])  # 3d array\n&gt;&gt;&gt; zoomed = zoom(x, [1, 2, 3])  # different scales along each axes\n&gt;&gt;&gt; zoomed = zoom(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n</code></pre> Source code in <code>imops/zoom.py</code> <pre><code>def zoom(\nx: np.ndarray,\nscale_factor: AxesParams,\naxis: AxesLike = None,\norder: int = 1,\nfill_value: Union[float, Callable] = 0,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Rescale `x` according to `scale_factor` along the `axis`.\n    Uses a fast parallelizable implementation for fp32 / fp64 (and int16-32-64 if order == 0) inputs,\n    ndim &lt;= 4 and order = 0 or 1.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array\n    scale_factor: AxesParams\n        float or sequence of floats describing how to scale along axes\n    axis: AxesLike\n        axis along which array will be scaled\n    order: int\n        order of interpolation\n    fill_value: float | Callable\n        value to fill past edges. If Callable (e.g. `numpy.min`) - `fill_value(x)` will be used\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `numba`, `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    zoomed: np.ndarray\n        zoomed array\n    Examples\n    --------\n    &gt;&gt;&gt; zoomed = zoom(x, 2, axis=[0, 1])  # 3d array\n    &gt;&gt;&gt; zoomed = zoom(x, [1, 2, 3])  # different scales along each axes\n    &gt;&gt;&gt; zoomed = zoom(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n    \"\"\"\nx = np.asarray(x)\naxis, scale_factor = broadcast_axis(axis, x.ndim, scale_factor)\nscale_factor = fill_by_indices(np.ones(x.ndim, 'float64'), scale_factor, axis)\nif callable(fill_value):\nfill_value = fill_value(x)\nreturn _zoom(x, scale_factor, order=order, cval=fill_value, num_threads=num_threads, backend=backend)\n</code></pre>"},{"location":"#imops.zoom.zoom_to_shape","title":"<code>imops.zoom.zoom_to_shape(x, shape, axis=None, order=1, fill_value=0, num_threads=-1, backend=None)</code>","text":"<p>Rescale <code>x</code> to match <code>shape</code> along the <code>axis</code>.</p> <p>Uses a fast parallelizable implementation for fp32 / fp64 (and int16-32-64 if order == 0) inputs, ndim &lt;= 4 and order = 0 or 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>shape</code> <code>AxesLike</code> <p>float or sequence of floats describing desired lengths along axes</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which array will be scaled</p> <code>None</code> <code>order</code> <code>int</code> <p>order of interpolation</p> <code>1</code> <code>fill_value</code> <code>Union[float, Callable]</code> <p>value to fill past edges. If Callable (e.g. <code>numpy.min</code>) - <code>fill_value(x)</code> will be used</p> <code>0</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zoomed</code> <code>np.ndarray</code> <p>zoomed array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zoomed = zoom_to_shape(x, [3, 4, 5])  # 3d array\n&gt;&gt;&gt; zoomed = zoom_to_shape(x, [6, 7], axis=[1, 2])  # zoom to shape along specified axes\n&gt;&gt;&gt; zoomed = zoom_to_shape(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n</code></pre> Source code in <code>imops/zoom.py</code> <pre><code>def zoom_to_shape(\nx: np.ndarray,\nshape: AxesLike,\naxis: AxesLike = None,\norder: int = 1,\nfill_value: Union[float, Callable] = 0,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Rescale `x` to match `shape` along the `axis`.\n    Uses a fast parallelizable implementation for fp32 / fp64 (and int16-32-64 if order == 0) inputs,\n    ndim &lt;= 4 and order = 0 or 1.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array\n    shape: AxesLike\n        float or sequence of floats describing desired lengths along axes\n    axis: AxesLike\n        axis along which array will be scaled\n    order: int\n        order of interpolation\n    fill_value: float | Callable\n        value to fill past edges. If Callable (e.g. `numpy.min`) - `fill_value(x)` will be used\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `numba`, `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    zoomed: np.ndarray\n        zoomed array\n    Examples\n    --------\n    &gt;&gt;&gt; zoomed = zoom_to_shape(x, [3, 4, 5])  # 3d array\n    &gt;&gt;&gt; zoomed = zoom_to_shape(x, [6, 7], axis=[1, 2])  # zoom to shape along specified axes\n    &gt;&gt;&gt; zoomed = zoom_to_shape(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n    \"\"\"\nx = np.asarray(x)\naxis, shape = broadcast_axis(axis, x.ndim, shape)\nold_shape = np.array(x.shape, 'float64')\nnew_shape = np.array(fill_by_indices(x.shape, shape, axis), 'float64')\nreturn zoom(\nx,\nnew_shape / old_shape,\nrange(x.ndim),\norder=order,\nfill_value=fill_value,\nnum_threads=num_threads,\nbackend=backend,\n)\n</code></pre>"},{"location":"#imops.interp1d.interp1d","title":"<code>imops.interp1d.interp1d</code>","text":"<p>Faster parallelizable version of <code>scipy.interpolate.interp1d</code> for fp32 / fp64 inputs.</p> <p>Works faster only for ndim &lt;= 3. Shares interface with <code>scipy.interpolate.interp1d</code> except for <code>num_threads</code> and <code>backend</code> arguments.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>1-dimensional array of real values (aka coordinates)</p> required <code>y</code> <code>np.ndarray</code> <p>n-dimensional array of real values. The length of y along the interpolation axis must be equal to the x length</p> required <code>kind</code> <code>Union[int, str]</code> <p>specifies the kind of interpolation as a string or as an integer specifying the order of interpolation to use. Only kind=1 and 'linear<code>are fast and parallelizable, other kinds will force to use</code>scipy` implementation</p> <code>'linear'</code> <code>axis</code> <code>int</code> <p>specifies the axis of y along which to interpolate. Interpolation defaults to the last axis of y</p> <code>-1</code> <code>copy</code> <code>bool</code> <p>if True, the class makes internal copies of x and y. If False, references to x and y are used</p> <code>True</code> <code>bounds_error</code> <code>bool</code> <p>if True, a ValueError is raised any time interpolation is attempted on a value outside of the range of x where extrapolation is necessary. If False, out of bounds values are assigned fill_value. By default, an error is raised unless fill_value='extrapolate'</p> <code>None</code> <code>fill_value</code> <code>Union[float, str]</code> <p>if a float, this value will be used to fill in for requested points outside of the data range. If not provided, then the default is NaN. If 'extrapolate', values for points outside of the data range will be extrapolated</p> <code>np.nan</code> <code>assume_sorted</code> <code>bool</code> <p>if False, values of x can be in any order and they are sorted first. If True, x has to be an array of monotonically increasing values</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code>"},{"location":"#imops.interp1d.interp1d--methods","title":"Methods","text":"<p>call</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from imops.interp1d import interp1d\n&gt;&gt;&gt; x = np.arange(0, 10)\n&gt;&gt;&gt; y = np.exp(-x/3.0)\n&gt;&gt;&gt; f = interp1d(x, y)\n&gt;&gt;&gt; xnew = np.arange(0, 9, 0.1)\n&gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d`\n</code></pre> Source code in <code>imops/interp1d.py</code> <pre><code>class interp1d:\n\"\"\"\n    Faster parallelizable version of `scipy.interpolate.interp1d` for fp32 / fp64 inputs.\n    Works faster only for ndim &lt;= 3. Shares interface with `scipy.interpolate.interp1d` except for `num_threads` and\n    `backend` arguments.\n    Parameters\n    ----------\n    x: np.ndarray\n        1-dimensional array of real values (aka coordinates)\n    y: np.ndarray\n        n-dimensional array of real values. The length of y along the interpolation axis must be equal to the x length\n    kind: Union[int, str]\n        specifies the kind of interpolation as a string or as an integer specifying the order of interpolation to use.\n        Only kind=1 and 'linear` are fast and parallelizable, other kinds will force to use `scipy` implementation\n    axis: int\n        specifies the axis of y along which to interpolate. Interpolation defaults to the last axis of y\n    copy: bool\n        if True, the class makes internal copies of x and y. If False, references to x and y are used\n    bounds_error: bool\n        if True, a ValueError is raised any time interpolation is attempted on a value outside of the range of x where\n        extrapolation is necessary. If False, out of bounds values are assigned fill_value. By default, an error is\n        raised unless fill_value='extrapolate'\n    fill_value: Union[float, str]\n        if a float, this value will be used to fill in for requested points outside of the data range. If not provided,\n        then the default is NaN. If 'extrapolate', values for points outside of the data range will be extrapolated\n    assume_sorted: bool\n        if False, values of x can be in any order and they are sorted first. If True, x has to be an array of\n        monotonically increasing values\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `numba`, `cython` and `scipy` are available, `cython` is used by default\n    Methods\n    -------\n    __call__\n    Examples\n    --------\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from imops.interp1d import interp1d\n    &gt;&gt;&gt; x = np.arange(0, 10)\n    &gt;&gt;&gt; y = np.exp(-x/3.0)\n    &gt;&gt;&gt; f = interp1d(x, y)\n    &gt;&gt;&gt; xnew = np.arange(0, 9, 0.1)\n    &gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d`\n    \"\"\"\ndef __init__(\nself,\nx: np.ndarray,\ny: np.ndarray,\nkind: Union[int, str] = 'linear',\naxis: int = -1,\ncopy: bool = True,\nbounds_error: bool = None,\nfill_value: Union[float, str] = np.nan,\nassume_sorted: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; None:\nbackend = resolve_backend(backend)\nif backend.name not in ('Scipy', 'Numba', 'Cython'):\nraise ValueError(f'Unsupported backend \"{backend.name}\".')\nself.backend = backend\nself.dtype = y.dtype\nself.num_threads = num_threads\nif backend.name == 'Scipy':\nself.scipy_interp1d = scipy_interp1d(x, y, kind, axis, copy, bounds_error, fill_value, assume_sorted)\nelif self.dtype not in (np.float32, np.float64) or y.ndim &gt; 3 or kind not in ('linear', 1):\nwarn(\n\"Fast interpolation is only supported for ndim&lt;=3, dtype=float32 or float64, order=1 or 'linear'. \"\n\"Falling back to scipy's implementation.\",\n)\nself.scipy_interp1d = scipy_interp1d(x, y, kind, axis, copy, bounds_error, fill_value, assume_sorted)\nelse:\nif bounds_error and fill_value == 'extrapolate':\nraise ValueError('Cannot extrapolate and raise at the same time.')\nif fill_value == 'extrapolate' and len(x) &lt; 2 or len(y) &lt; 2:\nraise ValueError('x and y arrays must have at least 2 entries.')\nif fill_value == 'extrapolate':\nself.bounds_error = False\nelse:\nself.bounds_error = True if bounds_error is None else bounds_error\nif len(x) != y.shape[axis]:\nraise ValueError(\nf'x and y arrays must be equal in length along interpolation axis: {len(x)} vs {y.shape[axis]}.'\n)\nself.axis = axis\nif axis not in (-1, y.ndim - 1):\ny = np.swapaxes(y, -1, axis)\nself.fill_value = fill_value\nself.scipy_interp1d = None\nself.x = np.copy(x) if copy else x\nself.n_dummy = 3 - y.ndim\nself.y = y[(None,) * self.n_dummy] if self.n_dummy else y\nif copy:\nself.y = np.copy(self.y)\nself.assume_sorted = assume_sorted\nif backend.name == 'Cython':\nself.src_interp1d = cython_fast_interp1d if backend.fast else cython_interp1d\nif backend.name == 'Numba':\nfrom numba import njit\nfrom .src._numba_zoom import _interp1d as numba_interp1d\nnjit_kwargs = {kwarg: getattr(backend, kwarg) for kwarg in backend.__dataclass_fields__.keys()}\nself.src_interp1d = njit(**njit_kwargs)(numba_interp1d)\ndef __call__(self, x_new: np.ndarray) -&gt; np.ndarray:\n\"\"\"\n        Evaluate the interpolant\n        Parameters\n        ----------\n        x_new: np.ndarray\n            1d array points to evaluate the interpolant at.\n        Returns\n        -------\n        y_new: np.ndarray\n            interpolated values. Shape is determined by replacing the interpolation axis in the original array with\n            the shape of x\n        \"\"\"\nnum_threads = normalize_num_threads(self.num_threads, self.backend)\nif self.scipy_interp1d is not None:\nreturn self.scipy_interp1d(x_new)\nextrapolate = self.fill_value == 'extrapolate'\nargs = () if self.backend.name in ('Numba',) else (num_threads,)\nif self.backend.name == 'Numba':\nfrom numba import get_num_threads, set_num_threads\nold_num_threads = get_num_threads()\nset_num_threads(num_threads)\n# TODO: Figure out how to properly handle multiple type signatures in Cython and remove `.astype`-s\nout = self.src_interp1d(\nself.y,\nself.x.astype(np.float64, copy=False),\nx_new.astype(np.float64, copy=False),\nself.bounds_error,\n0.0 if extrapolate else self.fill_value,\nextrapolate,\nself.assume_sorted,\n*args,\n)\nif self.backend.name == 'Numba':\nset_num_threads(old_num_threads)\nout = out.astype(max(self.y.dtype, self.x.dtype, x_new.dtype, key=lambda x: x.type(0).itemsize), copy=False)\nif self.n_dummy:\nout = out[(0,) * self.n_dummy]\nif self.axis not in (-1, out.ndim - 1):\nout = np.swapaxes(out, -1, self.axis)\n# FIXME: fix behaviour with np.inf-s\nif np.isnan(out).any():\nif not np.isinf(out).any():\nraise RuntimeError(\"Can't decide how to handle nans in the output.\")\nhave_neg = np.isneginf(out).any()\nhave_pos = np.isposinf(out).any()\nif have_pos and have_neg:\nraise RuntimeError(\"Can't decide how to handle nans in the output.\")\nif have_pos:\nreturn np.nan_to_num(out, copy=False, nan=np.inf, posinf=np.inf)\nreturn np.nan_to_num(out, copy=False, nan=-np.inf, neginf=-np.inf)\nreturn out\n</code></pre>"},{"location":"#imops.interp1d.interp1d.__call__","title":"<code>__call__(x_new)</code>","text":"<p>Evaluate the interpolant</p> <p>Parameters:</p> Name Type Description Default <code>x_new</code> <code>np.ndarray</code> <p>1d array points to evaluate the interpolant at.</p> required <p>Returns:</p> Name Type Description <code>y_new</code> <code>np.ndarray</code> <p>interpolated values. Shape is determined by replacing the interpolation axis in the original array with the shape of x</p> Source code in <code>imops/interp1d.py</code> <pre><code>def __call__(self, x_new: np.ndarray) -&gt; np.ndarray:\n\"\"\"\n    Evaluate the interpolant\n    Parameters\n    ----------\n    x_new: np.ndarray\n        1d array points to evaluate the interpolant at.\n    Returns\n    -------\n    y_new: np.ndarray\n        interpolated values. Shape is determined by replacing the interpolation axis in the original array with\n        the shape of x\n    \"\"\"\nnum_threads = normalize_num_threads(self.num_threads, self.backend)\nif self.scipy_interp1d is not None:\nreturn self.scipy_interp1d(x_new)\nextrapolate = self.fill_value == 'extrapolate'\nargs = () if self.backend.name in ('Numba',) else (num_threads,)\nif self.backend.name == 'Numba':\nfrom numba import get_num_threads, set_num_threads\nold_num_threads = get_num_threads()\nset_num_threads(num_threads)\n# TODO: Figure out how to properly handle multiple type signatures in Cython and remove `.astype`-s\nout = self.src_interp1d(\nself.y,\nself.x.astype(np.float64, copy=False),\nx_new.astype(np.float64, copy=False),\nself.bounds_error,\n0.0 if extrapolate else self.fill_value,\nextrapolate,\nself.assume_sorted,\n*args,\n)\nif self.backend.name == 'Numba':\nset_num_threads(old_num_threads)\nout = out.astype(max(self.y.dtype, self.x.dtype, x_new.dtype, key=lambda x: x.type(0).itemsize), copy=False)\nif self.n_dummy:\nout = out[(0,) * self.n_dummy]\nif self.axis not in (-1, out.ndim - 1):\nout = np.swapaxes(out, -1, self.axis)\n# FIXME: fix behaviour with np.inf-s\nif np.isnan(out).any():\nif not np.isinf(out).any():\nraise RuntimeError(\"Can't decide how to handle nans in the output.\")\nhave_neg = np.isneginf(out).any()\nhave_pos = np.isposinf(out).any()\nif have_pos and have_neg:\nraise RuntimeError(\"Can't decide how to handle nans in the output.\")\nif have_pos:\nreturn np.nan_to_num(out, copy=False, nan=np.inf, posinf=np.inf)\nreturn np.nan_to_num(out, copy=False, nan=-np.inf, neginf=-np.inf)\nreturn out\n</code></pre>"},{"location":"#imops.morphology.binary_dilation","title":"<code>imops.morphology.binary_dilation(image, footprint=None, output=None, boxed=False, num_threads=-1, backend=None)</code>","text":"<p>Fast parallelizable binary morphological dilation of an image</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>input image</p> required <code>footprint</code> <code>np.ndarray</code> <p>the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)</p> <code>None</code> <code>output</code> <code>np.ndarray</code> <p>array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new array is created</p> <code>None</code> <code>boxed</code> <code>bool</code> <p>if True, dilation is performed on cropped image which may speed up computation depedning on how localized True pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is exotic (has even shape or center pixel is False)</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dilated</code> <code>np.ndarray</code> <p>the result of morphological dilation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dilated = binary_dilation(x)\n</code></pre> Source code in <code>imops/morphology.py</code> <pre><code>def binary_dilation(\nimage: np.ndarray,\nfootprint: np.ndarray = None,\noutput: np.ndarray = None,\nboxed: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Fast parallelizable binary morphological dilation of an image\n    Parameters\n    ----------\n    image: np.ndarray\n        input image\n    footprint: np.ndarray\n        the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)\n    output: np.ndarray\n        array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new\n        array is created\n    boxed: bool\n        if True, dilation is performed on cropped image which may speed up computation depedning on how localized True\n        pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is\n        exotic (has even shape or center pixel is False)\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    dilated: np.ndarray\n        the result of morphological dilation\n    Examples\n    --------\n    &gt;&gt;&gt; dilated = binary_dilation(x)\n    \"\"\"\nreturn _binary_dilation(image, footprint, output, boxed, num_threads, backend)\n</code></pre>"},{"location":"#imops.morphology.binary_erosion","title":"<code>imops.morphology.binary_erosion(image, footprint=None, output=None, boxed=False, num_threads=-1, backend=None)</code>","text":"<p>Fast parallelizable binary morphological erosion of an image</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>input image</p> required <code>footprint</code> <code>np.ndarray</code> <p>the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)</p> <code>None</code> <code>output</code> <code>np.ndarray</code> <p>array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new array is created</p> <code>None</code> <code>boxed</code> <code>bool</code> <p>if True, erosion is performed on cropped image which may speed up computation depedning on how localized True pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is exotic (has even shape or center pixel is False)</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>eroded</code> <code>np.ndarray</code> <p>the result of morphological erosion</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; eroded = binary_erosion(x)\n</code></pre> Source code in <code>imops/morphology.py</code> <pre><code>def binary_erosion(\nimage: np.ndarray,\nfootprint: np.ndarray = None,\noutput: np.ndarray = None,\nboxed: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Fast parallelizable binary morphological erosion of an image\n    Parameters\n    ----------\n    image: np.ndarray\n        input image\n    footprint: np.ndarray\n        the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)\n    output: np.ndarray\n        array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new\n        array is created\n    boxed: bool\n        if True, erosion is performed on cropped image which may speed up computation depedning on how localized True\n        pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is\n        exotic (has even shape or center pixel is False)\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    eroded: np.ndarray\n        the result of morphological erosion\n    Examples\n    --------\n    &gt;&gt;&gt; eroded = binary_erosion(x)\n    \"\"\"\nreturn _binary_erosion(image, footprint, output, boxed, num_threads, backend)\n</code></pre>"},{"location":"#imops.morphology.binary_opening","title":"<code>imops.morphology.binary_opening(image, footprint=None, output=None, boxed=False, num_threads=-1, backend=None)</code>","text":"<p>Fast parallelizable binary morphological opening of an image</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>input image</p> required <code>footprint</code> <code>np.ndarray</code> <p>the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)</p> <code>None</code> <code>output</code> <code>np.ndarray</code> <p>array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new array is created</p> <code>None</code> <code>boxed</code> <code>bool</code> <p>if True, opening is performed on cropped image which may speed up computation depedning on how localized True pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is exotic (has even shape or center pixel is False)</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>opened</code> <code>np.ndarray</code> <p>the result of morphological opening</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; opened = binary_opening(x)\n</code></pre> Source code in <code>imops/morphology.py</code> <pre><code>def binary_opening(\nimage: np.ndarray,\nfootprint: np.ndarray = None,\noutput: np.ndarray = None,\nboxed: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Fast parallelizable binary morphological opening of an image\n    Parameters\n    ----------\n    image: np.ndarray\n        input image\n    footprint: np.ndarray\n        the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)\n    output: np.ndarray\n        array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new\n        array is created\n    boxed: bool\n        if True, opening is performed on cropped image which may speed up computation depedning on how localized True\n        pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is\n        exotic (has even shape or center pixel is False)\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    opened: np.ndarray\n        the result of morphological opening\n    Examples\n    --------\n    &gt;&gt;&gt; opened = binary_opening(x)\n    \"\"\"\nreturn _binary_opening(image, footprint, output, boxed, num_threads, backend)\n</code></pre>"},{"location":"#imops.morphology.binary_closing","title":"<code>imops.morphology.binary_closing(image, footprint=None, output=None, boxed=False, num_threads=-1, backend=None)</code>","text":"<p>Fast parallelizable binary morphological closing of an image</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>input image</p> required <code>footprint</code> <code>np.ndarray</code> <p>the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)</p> <code>None</code> <code>output</code> <code>np.ndarray</code> <p>array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new array is created</p> <code>None</code> <code>boxed</code> <code>bool</code> <p>if True, closing is performed on cropped image which may speed up computation depedning on how localized True pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is exotic (has even shape or center pixel is False)</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>closed</code> <code>np.ndarray</code> <p>the result of morphological closing</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; closed = binary_closing(x)\n</code></pre> Source code in <code>imops/morphology.py</code> <pre><code>def binary_closing(\nimage: np.ndarray,\nfootprint: np.ndarray = None,\noutput: np.ndarray = None,\nboxed: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Fast parallelizable binary morphological closing of an image\n    Parameters\n    ----------\n    image: np.ndarray\n        input image\n    footprint: np.ndarray\n        the neighborhood expressed as a n-D array of 1's and 0's. If None, use a cross-shaped footprint (connectivity=1)\n    output: np.ndarray\n        array of the same shape as input, into which the output is placed (must be C-contiguous). By default, a new\n        array is created\n    boxed: bool\n        if True, closing is performed on cropped image which may speed up computation depedning on how localized True\n        pixels are. This may induce differences with Scikit-Image implementation at border pixels if footprint is\n        exotic (has even shape or center pixel is False)\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    closed: np.ndarray\n        the result of morphological closing\n    Examples\n    --------\n    &gt;&gt;&gt; closed = binary_closing(x)\n    \"\"\"\nreturn _binary_closing(image, footprint, output, boxed, num_threads, backend)\n</code></pre>"},{"location":"#imops.measure.label","title":"<code>imops.measure.label(label_image, background=None, connectivity=None, return_num=False, return_labels=False, return_sizes=False, dtype=None)</code>","text":"<p>Fast version of <code>skimage.measure.label</code> which optionally returns number of connected components, labels and sizes. If 2 or more outputs are requested <code>NamedTuple</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>label_image</code> <code>np.ndarray</code> <p>image to label</p> required <code>background</code> <code>int</code> <p>consider all pixels with this value as background pixels, and label them as 0. By default, 0-valued pixels are considered as background pixels</p> <code>None</code> <code>connectivity</code> <code>int</code> <p>maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If None, a full connectivity of input.ndim is used</p> <code>None</code> <code>return_num</code> <code>bool</code> <p>whether to return the number of connected components</p> <code>False</code> <code>return_labels</code> <code>bool</code> <p>whether to return assigned labels</p> <code>False</code> <code>return_sizes</code> <code>bool</code> <p>whether to return sizes of connected components (excluding background)</p> <code>False</code> <code>dtype</code> <code>type</code> <p>if specified, must be one of np.uint16, np.uint32 or np.uint64. If not specified, it will be automatically determined. Most of the time, you should leave this off so that the smallest safe dtype will be used. However, in some applications you can save an up-conversion in the next operation by outputting the appropriately sized type instead. Has no effect for python3.6</p> <code>None</code> <p>Returns:</p> Name Type Description <code>labeled_image</code> <code>np.ndarray</code> <p>array of np.uint16, np.uint32 or np.uint64 numbers depending on the number of connected components and <code>dtype</code></p> <code>num_components</code> <code>int</code> <p>number of connected components excluding background. Returned if <code>return_num</code> is True</p> <code>labels</code> <code>np.ndarray</code> <p>components labels. Returned if <code>return_labels</code> is True</p> <code>sizes</code> <code>np.ndarray</code> <p>components sizes. Returned if <code>return_sizes</code> is True</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; labeled = label(x)\n&gt;&gt;&gt; labeled, num_components, sizes = label(x, return_num=True, return_sizes=True)\n&gt;&gt;&gt; out = label(x, return_labels=True, return_sizes=True)\n&gt;&gt;&gt; out.labeled_image, out.labels, out.sizes  # output fields can be accessed this way\n</code></pre> Source code in <code>imops/measure.py</code> <pre><code>def label(\nlabel_image: np.ndarray,\nbackground: int = None,\nconnectivity: int = None,\nreturn_num: bool = False,\nreturn_labels: bool = False,\nreturn_sizes: bool = False,\ndtype: type = None,\n) -&gt; Union[np.ndarray, NamedTuple]:\n\"\"\"\n    Fast version of `skimage.measure.label` which optionally returns number of connected components, labels and sizes.\n    If 2 or more outputs are requested `NamedTuple` is returned.\n    Parameters\n    ----------\n    label_image: np.ndarray\n        image to label\n    background: int\n        consider all pixels with this value as background pixels, and label them as 0. By default, 0-valued pixels are\n        considered as background pixels\n    connectivity: int\n        maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1\n        to input.ndim. If None, a full connectivity of input.ndim is used\n    return_num: bool\n        whether to return the number of connected components\n    return_labels: bool\n        whether to return assigned labels\n    return_sizes: bool\n        whether to return sizes of connected components (excluding background)\n    dtype:\n        if specified, must be one of np.uint16, np.uint32 or np.uint64. If not specified, it will be automatically\n        determined. Most of the time, you should leave this off so that the smallest safe dtype will be used. However,\n        in some applications you can save an up-conversion in the next operation by outputting the appropriately sized\n        type instead. Has no effect for python3.6\n    Returns\n    -------\n    labeled_image: np.ndarray\n        array of np.uint16, np.uint32 or np.uint64 numbers depending on the number of connected components and\n        `dtype`\n    num_components: int\n        number of connected components excluding background. Returned if `return_num` is True\n    labels: np.ndarray\n        components labels. Returned if `return_labels` is True\n    sizes: np.ndarray\n        components sizes. Returned if `return_sizes` is True\n    Examples\n    --------\n    &gt;&gt;&gt; labeled = label(x)\n    &gt;&gt;&gt; labeled, num_components, sizes = label(x, return_num=True, return_sizes=True)\n    &gt;&gt;&gt; out = label(x, return_labels=True, return_sizes=True)\n    &gt;&gt;&gt; out.labeled_image, out.labels, out.sizes  # output fields can be accessed this way\n    \"\"\"\nndim = label_image.ndim\nconnectivity = connectivity or ndim\nif not 1 &lt;= connectivity &lt;= ndim:\nraise ValueError(f'Connectivity for {ndim}D image should be in [1, ..., {ndim}]. Got {connectivity}.')\nif ndim &gt; 3:\nwarn(\"Fast label is only supported for ndim&lt;=3, Falling back to scikit-image's implementation.\")\nlabeled_image, num_components = skimage_label(\nlabel_image, background=background, return_num=True, connectivity=connectivity\n)\nif dtype is not None:\nlabeled_image = labeled_image.astype(dtype, copy=False)\nelse:\nif ndim == 1:\nlabel_image = label_image[None]\nif background:\nlabel_image = remap(\nlabel_image,\n{background: 0, 0: background},\npreserve_missing_labels=True,\nin_place=False,\n)\nlabeled_image, num_components = connected_components(\nlabel_image,\nconnectivity=skimage2cc3d[(ndim, connectivity)],\nreturn_N=True,\n**{'out_dtype': dtype} if python_version()[:3] != '3.6' else {},\n)\nif ndim == 1:\nlabeled_image = labeled_image[0]\nres = [('labeled_image', labeled_image)]\nif return_num:\nres.append(('num_components', num_components))\nif return_labels:\nres.append(('labels', np.array(range(1, num_components + 1))))\nif return_sizes:\n_, sizes = unique(labeled_image, return_counts=True)\nres.append(('sizes', sizes[1:] if 0 in labeled_image else sizes))\nif len(res) == 1:\nreturn labeled_image\nreturn namedtuple('Labeling', [subres[0] for subres in res])(*[subres[1] for subres in res])\n</code></pre>"},{"location":"#imops.measure.center_of_mass","title":"<code>imops.measure.center_of_mass(array, labels=None, index=None, num_threads=-1, backend=None)</code>","text":"<p>Calculate the center of mass of the values.</p> <p>Works faster for ndim &lt;= 3</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>data from which to calculate center-of-mass. The masses can either be positive or negative</p> required <code>labels</code> <code>np.ndarray</code> <p>labels for objects in input, as generated by <code>imops.measure.label</code>. Dimensions must be the same as input. If specified, <code>index</code> also must be specified and have same dtype</p> <code>None</code> <code>index</code> <code>Union[int, Sequence[int]]</code> <p>labels for which to calculate centers-of-mass. If specified, <code>labels</code> also must be specified and have same dtype</p> <code>None</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used. If <code>labels</code> and <code>index</code> are specified, only 1 thread will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>center_of_mass</code> <code>tuple, or list of tuples</code> <p>coordinates of centers-of-mass</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; center = center_of_mass(np.ones((2, 2)))  # (0.5, 0.5)\n</code></pre> Source code in <code>imops/measure.py</code> <pre><code>def center_of_mass(\narray: np.ndarray,\nlabels: np.ndarray = None,\nindex: Union[int, Sequence[int]] = None,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; Union[Tuple[float, ...], List[Tuple[float, ...]]]:\n\"\"\"\n    Calculate the center of mass of the values.\n    Works faster for ndim &lt;= 3\n    Parameters\n    ----------\n    array: np.ndarray\n        data from which to calculate center-of-mass. The masses can either be positive or negative\n    labels: np.ndarray\n        labels for objects in input, as generated by `imops.measure.label`. Dimensions must be the same as input. If\n        specified, `index` also must be specified and have same dtype\n    index: Union[int, Sequence[int]]\n        labels for which to calculate centers-of-mass. If specified, `labels` also must be specified and have same dtype\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used. If `labels` and `index` are specified, only 1 thread will be\n        used\n    backend: BackendLike\n        which backend to use. `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    center_of_mass: tuple, or list of tuples\n        coordinates of centers-of-mass\n    Examples\n    --------\n    &gt;&gt;&gt; center = center_of_mass(np.ones((2, 2)))  # (0.5, 0.5)\n    \"\"\"\nif (labels is None) ^ (index is None):\nraise ValueError('`labels` and `index` should be both specified or both not specified.')\nbackend = resolve_backend(backend)\nif backend.name not in ('Scipy', 'Cython'):\nraise ValueError(f'Unsupported backend \"{backend.name}\".')\nnum_threads = normalize_num_threads(num_threads, backend)\nif backend.name == 'Scipy':\nreturn scipy_center_of_mass(array, labels, index)\nndim = array.ndim\nif ndim &gt; 3:\nwarn(\"Fast center-of-mass is only supported for ndim&lt;=4. Falling back to scipy's implementation.\")\nreturn scipy_center_of_mass(array, labels, index)\nif labels is None:\nsrc_center_of_mass = _fast_center_of_mass if backend.fast else _center_of_mass\nelse:\nis_sequence = isinstance(index, (Sequence, np.ndarray))\nindex = np.array([index] if not is_sequence else index)\nif labels.dtype != index.dtype:\nraise ValueError(f'`labels` and `index` must have same dtype, got {labels.dtype} and {index.dtype}.')\nif len(index) != len(unique(index.astype(int, copy=False))):\nraise ValueError('`index` should consist of unique values.')\nif num_threads &gt; 1:\nwarn('Using single-threaded implementation as `labels` and `index` are specified.')\nsrc_center_of_mass = _fast_labeled_center_of_mass if backend.fast else _labeled_center_of_mass\nif array.dtype != 'float64':\narray = array.astype(float)\nn_dummy = 3 - ndim\nif n_dummy:\narray = array[(None,) * n_dummy]\nif labels is None:\nreturn tuple(src_center_of_mass(array, num_threads))[n_dummy:]\noutput = [tuple(x)[n_dummy:] for x in src_center_of_mass(array, labels[(None,) * n_dummy], index)]\nreturn output if is_sequence else output[0]\n</code></pre>"},{"location":"#imops.radon.radon","title":"<code>imops.radon.radon(image, axes=None, theta=180, return_fill=False, num_threads=-1, backend=None)</code>","text":"<p>Fast implementation of Radon transform. Adapted from scikit-image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>an n-dimensional array with at least 2 axes</p> required <code>axes</code> <code>Tuple[int, int]</code> <p>the axes in the <code>image</code> along which the Radon transform will be applied. The <code>image</code> shape along the <code>axes</code> must be of the same length</p> <code>None</code> <code>theta</code> <code>Union[int, Sequence[float]]</code> <p>the angles for which the Radon transform will be computed. If it is an integer - the angles will be evenly distributed between 0 and 180, <code>theta</code> values in total</p> <code>180</code> <code>return_fill</code> <code>bool</code> <p>whether to return the value that fills the image outside the circle working area</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to be used for parallel computation. By default - equals to the number of cpu cores</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>the execution backend. Currently only \"Cython\" is avaliable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sinogram</code> <code>np.ndarray</code> <p>the result of the Radon transform</p> <code>fill_value</code> <code>float</code> <p>the value that fills the image outside the circle working area. Returned only if <code>return_fill</code> is True</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sinogram = radon(image)  # 2d image\n&gt;&gt;&gt; sinogram, fill_value = radon(image, return_fill=True)  # 2d image with fill value\n&gt;&gt;&gt; sinogram = radon(image, axes=(-2, -1))  # nd image\n</code></pre> Source code in <code>imops/radon.py</code> <pre><code>def radon(\nimage: np.ndarray,\naxes: Tuple[int, int] = None,\ntheta: Union[int, Sequence[float]] = 180,\nreturn_fill: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; Union[np.ndarray, Tuple[np.ndarray, float]]:\n\"\"\"\n    Fast implementation of Radon transform. Adapted from scikit-image.\n    Parameters\n    ----------\n    image: np.ndarray\n        an n-dimensional array with at least 2 axes\n    axes: tuple[int, int]\n        the axes in the `image` along which the Radon transform will be applied.\n        The `image` shape along the `axes` must be of the same length\n    theta: int | Sequence[float]\n        the angles for which the Radon transform will be computed. If it is an integer - the angles will\n        be evenly distributed between 0 and 180, `theta` values in total\n    return_fill: bool\n        whether to return the value that fills the image outside the circle working area\n    num_threads: int\n        the number of threads to be used for parallel computation. By default - equals to the number of cpu cores\n    backend: str | Backend\n        the execution backend. Currently only \"Cython\" is avaliable\n    Returns\n    -------\n    sinogram: np.ndarray\n        the result of the Radon transform\n    fill_value: float\n        the value that fills the image outside the circle working area. Returned only if `return_fill` is True\n    Examples\n    --------\n    &gt;&gt;&gt; sinogram = radon(image)  # 2d image\n    &gt;&gt;&gt; sinogram, fill_value = radon(image, return_fill=True)  # 2d image with fill value\n    &gt;&gt;&gt; sinogram = radon(image, axes=(-2, -1))  # nd image\n    \"\"\"\nbackend = resolve_backend(backend)\nif backend.name not in ('Cython',):\nraise ValueError(f'Unsupported backend \"{backend.name}\".')\nimage, axes, extra = normalize_axes(image, axes)\nif image.shape[1] != image.shape[2]:\nraise ValueError(\nf'The image must be square along the provided axes ({axes}), but has shape: {image.shape[1:]}.'\n)\nif isinstance(theta, int):\ntheta = np.linspace(0, 180, theta, endpoint=False)\nsize = image.shape[1]\nradius = size // 2\nxs = np.arange(-radius, size - radius)\nsquared = xs**2\noutside_circle = (squared[:, None] + squared[None, :]) &gt; radius**2\nvalues = image[:, outside_circle]\nmin_, max_ = values.min(), values.max()\nif max_ - min_ &gt; 0.1:\nraise ValueError(\nf'The image must be constant outside the circle. ' f'Got values ranging from {min_} to {max_}.'\n)\nif min_ != 0 or max_ != 0:\nimage = image.copy()\nimage[:, outside_circle] = 0\n# TODO: f(arange)?\nlimits = ((squared[:, None] + squared[None, :]) &gt; (radius + 2) ** 2).sum(0) // 2\nnum_threads = normalize_num_threads(num_threads, backend)\nradon3d_ = fast_radon3d if backend.fast else radon3d\nsinogram = radon3d_(image, np.deg2rad(theta, dtype=image.dtype), limits, num_threads)\nresult = restore_axes(sinogram, axes, extra)\nif return_fill:\nresult = result, min_\nreturn result\n</code></pre>"},{"location":"#imops.radon.inverse_radon","title":"<code>imops.radon.inverse_radon(sinogram, axes=None, theta=None, fill_value=0, a=0, b=1, num_threads=-1, backend=None)</code>","text":"<p>Fast implementation of inverse Radon transform. Adapted from scikit-image.</p> <p>Parameters:</p> Name Type Description Default <code>sinogram</code> <code>np.ndarray</code> <p>an n-dimensional array with at least 2 axes</p> required <code>axes</code> <code>Tuple[int, int]</code> <p>the axes in the <code>image</code> along which the inverse Radon transform will be applied</p> <code>None</code> <code>theta</code> <code>Union[int, Sequence[float]]</code> <p>the angles for which the inverse Radon transform will be computed. If it is an integer - the angles will be evenly distributed between 0 and 180, <code>theta</code> values in total</p> <code>None</code> <code>fill_value</code> <code>float</code> <p>the value that fills the image outside the circle working area. Can be returned by <code>radon</code></p> <code>0</code> <code>a</code> <code>float</code> <p>the first parameter of the sharpen filter</p> <code>0</code> <code>b</code> <code>float</code> <p>the second parameter of the sharpen filter</p> <code>1</code> <code>num_threads</code> <code>int</code> <p>the number of threads to be used for parallel computation. By default - equals to the number of cpu cores</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>the execution backend. Currently only \"Cython\" is avaliable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>image</code> <code>np.ndarray</code> <p>the result of the inverse Radon transform</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; image = inverse_radon(sinogram)  # 2d image\n&gt;&gt;&gt; image = inverse_radon(sinogram, fill_value=-1000)  # 2d image with fill value\n&gt;&gt;&gt; image = inverse_radon(sinogram, axes=(-2, -1))  # nd image\n</code></pre> Source code in <code>imops/radon.py</code> <pre><code>def inverse_radon(\nsinogram: np.ndarray,\naxes: Tuple[int, int] = None,\ntheta: Union[int, Sequence[float]] = None,\nfill_value: float = 0,\na: float = 0,\nb: float = 1,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Fast implementation of inverse Radon transform. Adapted from scikit-image.\n    Parameters\n    ----------\n    sinogram: np.ndarray\n        an n-dimensional array with at least 2 axes\n    axes: tuple[int, int]\n        the axes in the `image` along which the inverse Radon transform will be applied\n    theta: int | Sequence[float]\n        the angles for which the inverse Radon transform will be computed. If it is an integer - the angles will\n        be evenly distributed between 0 and 180, `theta` values in total\n    fill_value: float\n        the value that fills the image outside the circle working area. Can be returned by `radon`\n    a: float\n        the first parameter of the sharpen filter\n    b: float\n        the second parameter of the sharpen filter\n    num_threads: int\n        the number of threads to be used for parallel computation. By default - equals to the number of cpu cores\n    backend: str | Backend\n        the execution backend. Currently only \"Cython\" is avaliable\n    Returns\n    -------\n    image: np.ndarray\n        the result of the inverse Radon transform\n    Examples\n    --------\n    &gt;&gt;&gt; image = inverse_radon(sinogram)  # 2d image\n    &gt;&gt;&gt; image = inverse_radon(sinogram, fill_value=-1000)  # 2d image with fill value\n    &gt;&gt;&gt; image = inverse_radon(sinogram, axes=(-2, -1))  # nd image\n    \"\"\"\nbackend = resolve_backend(backend)\nif backend.name not in ('Cython',):\nraise ValueError(f'Unsupported backend \"{backend.name}\".')\nsinogram, axes, extra = normalize_axes(sinogram, axes)\nif theta is None:\ntheta = sinogram.shape[-1]\nif isinstance(theta, int):\ntheta = np.linspace(0, 180, theta, endpoint=False)\nangles_count = len(theta)\nif angles_count != sinogram.shape[-1]:\nraise ValueError(\nf'The given `theta` (size {angles_count}) does not match the number of '\nf'projections in `sinogram` ({sinogram.shape[-1]}).'\n)\noutput_size = sinogram.shape[1]\nsinogram = _sinogram_circle_to_square(sinogram)\nimg_shape = sinogram.shape[1]\n# Resize image to next power of two (but no less than 64) for\n# Fourier analysis; speeds up Fourier and lessens artifacts\n# TODO: why *2?\nprojection_size_padded = max(64, int(2 ** np.ceil(np.log2(2 * img_shape))))\npad_width = ((0, 0), (0, projection_size_padded - img_shape), (0, 0))\npadded_sinogram = np.pad(sinogram, pad_width, mode='constant', constant_values=0)\nfourier_filter = _smooth_sharpen_filter(projection_size_padded, a, b)\n# Apply filter in Fourier domain\nfourier_img = fft(padded_sinogram, axis=1) * fourier_filter\nfiltered_sinogram = np.real(ifft(fourier_img, axis=1)[:, :img_shape, :])\nradius = output_size // 2\nxs = np.arange(-radius, output_size - radius)\nsquared = xs**2\ninside_circle = (squared[:, None] + squared[None, :]) &lt;= radius**2\ndtype = sinogram.dtype\nfiltered_sinogram = filtered_sinogram.astype(dtype, copy=False)\ntheta, xs = np.deg2rad(theta, dtype=dtype), xs.astype(dtype, copy=False)\nnum_threads = normalize_num_threads(num_threads, backend)\nbackprojection3d_ = fast_backprojection3d if backend.fast else backprojection3d\nreconstructed = np.asarray(\nbackprojection3d_(filtered_sinogram, theta, xs, inside_circle, fill_value, img_shape, output_size, num_threads)\n)\nreturn restore_axes(reconstructed, axes, extra)\n</code></pre>"}]}