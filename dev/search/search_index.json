{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Imops","text":"<p>Efficient parallelizable algorithms for multidimensional arrays to speed up your data pipelines</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install imops  # default install with Cython backend\npip install imops[numba]  # additionally install Numba backend\n</code></pre>"},{"location":"#functions","title":"Functions","text":""},{"location":"#imops.radon.radon","title":"<code>imops.radon.radon(image, axes=None, theta=180, return_fill=False, num_threads=-1, backend=None)</code>","text":"<p>Fast implementation of Radon transform. Adapted from scikit-image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>an array with at least 2 axes</p> required <code>axes</code> <code>Tuple[int, int]</code> <p>the axes in the <code>image</code> along which the Radon transform will be applied. The <code>image</code> shape along the <code>axes</code> must be of the same length</p> <code>None</code> <code>theta</code> <code>Union[int, Sequence[float]]</code> <p>the angles for which the Radon transform will be computed. If it is an integer - the angles will be evenly distributed between 0 and 180, <code>theta</code> values in total</p> <code>180</code> <code>return_fill</code> <code>bool</code> <p>whether to return the value that fills the image outside the circle working area</p> <code>False</code> <code>num_threads</code> <code>int</code> <p>the number of threads to be used for parallel computation. By default - equals to the number of cpu cores</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>the execution backend. Currently only \"Cython\" is avaliable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>sinogram</code> <code>np.ndarray</code> <p>the result of the Radon transform</p> <code>fill_value</code> <code>float</code> <p>the value that fills the image outside the circle working area. Returned only if <code>return_fill</code> is True</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sinogram = radon(image)  # 2d image\n&gt;&gt;&gt; sinogram, fill_value = radon(image, return_fill=True)  # 2d image with fill value\n&gt;&gt;&gt; sinogram = radon(image, axes=(-2, -1))  # nd image\n</code></pre> Source code in <code>imops/radon.py</code> <pre><code>def radon(\nimage: np.ndarray,\naxes: Tuple[int, int] = None,\ntheta: Union[int, Sequence[float]] = 180,\nreturn_fill: bool = False,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; Union[np.ndarray, Tuple[np.ndarray, float]]:\n\"\"\"\n    Fast implementation of Radon transform. Adapted from scikit-image.\n    Parameters\n    ----------\n    image: np.ndarray\n        an array with at least 2 axes\n    axes: tuple[int, int]\n        the axes in the `image` along which the Radon transform will be applied.\n        The `image` shape along the `axes` must be of the same length\n    theta: int | Sequence[float]\n        the angles for which the Radon transform will be computed. If it is an integer - the angles will\n        be evenly distributed between 0 and 180, `theta` values in total\n    return_fill: bool\n        whether to return the value that fills the image outside the circle working area\n    num_threads: int\n        the number of threads to be used for parallel computation. By default - equals to the number of cpu cores\n    backend: str | Backend\n        the execution backend. Currently only \"Cython\" is avaliable\n    Returns\n    -------\n    sinogram: np.ndarray\n        the result of the Radon transform\n    fill_value: float\n        the value that fills the image outside the circle working area. Returned only if `return_fill` is True\n    Examples\n    --------\n    &gt;&gt;&gt; sinogram = radon(image)  # 2d image\n    &gt;&gt;&gt; sinogram, fill_value = radon(image, return_fill=True)  # 2d image with fill value\n    &gt;&gt;&gt; sinogram = radon(image, axes=(-2, -1))  # nd image\n    \"\"\"\nbackend = resolve_backend(backend)\nif backend.name not in ('Cython',):\nraise ValueError(f'Unsupported backend \"{backend.name}\".')\nimage, axes, extra = normalize_axes(image, axes)\nif image.shape[1] != image.shape[2]:\nraise ValueError(\nf'The image must be square along the provided axes ({axes}), but has shape: {image.shape[1:]}.'\n)\nif isinstance(theta, int):\ntheta = np.linspace(0, 180, theta, endpoint=False)\nsize = image.shape[1]\nradius = size // 2\nxs = np.arange(-radius, size - radius)\nsquared = xs**2\noutside_circle = (squared[:, None] + squared[None, :]) &gt; radius**2\nvalues = image[:, outside_circle]\nmin_, max_ = values.min(), values.max()\nif max_ - min_ &gt; 0.1:\nraise ValueError(\nf'The image must be constant outside the circle. ' f'Got values ranging from {min_} to {max_}.'\n)\nif min_ != 0 or max_ != 0:\nimage = image.copy()\nimage[:, outside_circle] = 0\n# TODO: f(arange)?\nlimits = ((squared[:, None] + squared[None, :]) &gt; (radius + 2) ** 2).sum(0) // 2\nnum_threads = normalize_num_threads(num_threads, backend)\nif backend.fast:\nwarn(FAST_MATH_WARNING)\nradon3d_ = fast_radon3d\nelse:\nradon3d_ = radon3d\nsinogram = radon3d_(image, np.deg2rad(theta), limits, num_threads)\nresult = restore_axes(sinogram, axes, extra)\nif return_fill:\nresult = result, min_\nreturn result\n</code></pre>"},{"location":"#imops.radon.inverse_radon","title":"<code>imops.radon.inverse_radon(sinogram, axes=None, theta=180, fill_value=0, a=0, b=1, num_threads=-1, backend=None)</code>","text":"<p>Fast implementation of inverse Radon transform. Adapted from scikit-image.</p> <p>Parameters:</p> Name Type Description Default <code>sinogram</code> <code>np.ndarray</code> <p>an array with at least 2 axes</p> required <code>axes</code> <code>Tuple[int, int]</code> <p>the axes in the <code>image</code> along which the inverse Radon transform will be applied. The <code>image</code> shape along the <code>axes</code> must be of the same length</p> <code>None</code> <code>theta</code> <code>Union[int, Sequence[float]]</code> <p>the angles for which the inverse Radon transform will be computed. If it is an integer - the angles will be evenly distributed between 0 and 180, <code>theta</code> values in total</p> <code>180</code> <code>fill_value</code> <code>float</code> <p>the value that fills the image outside the circle working area. Can be returned by <code>radon</code></p> <code>0</code> <code>a</code> <code>float</code> <p>the first parameter of the sharpen filter</p> <code>0</code> <code>b</code> <code>float</code> <p>the second parameter of the sharpen filter</p> <code>1</code> <code>num_threads</code> <code>int</code> <p>the number of threads to be used for parallel computation. By default - equals to the number of cpu cores</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>the execution backend. Currently only \"Cython\" is avaliable</p> <code>None</code> <p>Returns:</p> Name Type Description <code>image</code> <code>np.ndarray</code> <p>the result of the inverse Radon transform</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; image = inverse_radon(sinogram)  # 2d image\n&gt;&gt;&gt; image = inverse_radon(sinogram, fill_value=-1000)  # 2d image with fill value\n&gt;&gt;&gt; image = inverse_radon(sinogram, axes=(-2, -1))  # nd image\n</code></pre> Source code in <code>imops/radon.py</code> <pre><code>def inverse_radon(\nsinogram: np.ndarray,\naxes: Tuple[int, int] = None,\ntheta: Union[int, Sequence[float]] = 180,\nfill_value: float = 0,\na: float = 0,\nb: float = 1,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Fast implementation of inverse Radon transform. Adapted from scikit-image.\n    Parameters\n    ----------\n    sinogram: np.ndarray\n        an array with at least 2 axes\n    axes: tuple[int, int]\n        the axes in the `image` along which the inverse Radon transform will be applied.\n        The `image` shape along the `axes` must be of the same length\n    theta: int | Sequence[float]\n        the angles for which the inverse Radon transform will be computed. If it is an integer - the angles will\n        be evenly distributed between 0 and 180, `theta` values in total\n    fill_value: float\n        the value that fills the image outside the circle working area. Can be returned by `radon`\n    a: float\n        the first parameter of the sharpen filter\n    b: float\n        the second parameter of the sharpen filter\n    num_threads: int\n        the number of threads to be used for parallel computation. By default - equals to the number of cpu cores\n    backend: str | Backend\n        the execution backend. Currently only \"Cython\" is avaliable\n    Returns\n    -------\n    image: np.ndarray\n        the result of the inverse Radon transform\n    Examples\n    --------\n    &gt;&gt;&gt; image = inverse_radon(sinogram)  # 2d image\n    &gt;&gt;&gt; image = inverse_radon(sinogram, fill_value=-1000)  # 2d image with fill value\n    &gt;&gt;&gt; image = inverse_radon(sinogram, axes=(-2, -1))  # nd image\n    \"\"\"\nbackend = resolve_backend(backend)\nif backend.name not in ('Cython',):\nraise ValueError(f'Unsupported backend \"{backend.name}\".')\nsinogram, axes, extra = normalize_axes(sinogram, axes)\nif theta is None:\ntheta = sinogram.shape[-1]\nif isinstance(theta, int):\ntheta = np.linspace(0, 180, theta, endpoint=False)\nangles_count = len(theta)\nif angles_count != sinogram.shape[-1]:\nraise ValueError(\nf'The given `theta` (size {angles_count}) does not match the number of '\nf'projections in `sinogram` ({sinogram.shape[-1]}).'\n)\noutput_size = sinogram.shape[1]\nsinogram = _sinogram_circle_to_square(sinogram)\nimg_shape = sinogram.shape[1]\n# Resize image to next power of two (but no less than 64) for\n# Fourier analysis; speeds up Fourier and lessens artifacts\n# TODO: why *2?\nprojection_size_padded = max(64, int(2 ** np.ceil(np.log2(2 * img_shape))))\npad_width = ((0, 0), (0, projection_size_padded - img_shape), (0, 0))\npadded_sinogram = np.pad(sinogram, pad_width, mode='constant', constant_values=0)\nfourier_filter = _smooth_sharpen_filter(projection_size_padded, a, b)\n# Apply filter in Fourier domain\nfourier_img = fft(padded_sinogram, axis=1) * fourier_filter\nfiltered_sinogram = np.real(ifft(fourier_img, axis=1)[:, :img_shape, :])\nradius = output_size // 2\nxs = np.arange(-radius, output_size - radius)\nsquared = xs**2\ninside_circle = (squared[:, None] + squared[None, :]) &lt;= radius**2\ndtype = sinogram.dtype\nfiltered_sinogram = filtered_sinogram.astype(dtype)\ntheta, xs = np.deg2rad(theta).astype(dtype), xs.astype(dtype)\nnum_threads = normalize_num_threads(num_threads, backend)\nif backend.fast:\nwarn(FAST_MATH_WARNING)\nbackprojection3d_ = fast_backprojection3d\nelse:\nbackprojection3d_ = backprojection3d\nreconstructed = np.asarray(\nbackprojection3d_(filtered_sinogram, theta, xs, inside_circle, fill_value, img_shape, output_size, num_threads)\n)\nreturn restore_axes(reconstructed, axes, extra)\n</code></pre>"},{"location":"#imops.zoom.zoom","title":"<code>imops.zoom.zoom(x, scale_factor, axis=None, order=1, fill_value=0, num_threads=-1, backend=None)</code>","text":"<p>Rescale <code>x</code> according to <code>scale_factor</code> along the <code>axis</code>.</p> <p>Uses a fast parallelizable implementation for fp32 / fp64 inputs, ndim &lt;= 3 and order = 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>scale_factor</code> <code>AxesParams</code> <p>float or sequence of floats describing how to scale along axes</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which array will be scaled</p> <code>None</code> <code>order</code> <code>int</code> <p>order of interpolation</p> <code>1</code> <code>fill_value</code> <code>Union[float, Callable]</code> <p>value to fill past edges. If Callable (e.g. <code>numpy.min</code>) - <code>fill_value(x)</code> will be used</p> <code>0</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zoomed</code> <code>np.ndarray</code> <p>zoomed array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zoomed = zoom(x, 2, axis=[0, 1])  # 3d array\n&gt;&gt;&gt; zoomed = zoom(x, [1, 2, 3])  # different scales along each axes\n&gt;&gt;&gt; zoomed = zoom(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n</code></pre> Source code in <code>imops/zoom.py</code> <pre><code>def zoom(\nx: np.ndarray,\nscale_factor: AxesParams,\naxis: AxesLike = None,\norder: int = 1,\nfill_value: Union[float, Callable] = 0,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Rescale `x` according to `scale_factor` along the `axis`.\n    Uses a fast parallelizable implementation for fp32 / fp64 inputs, ndim &lt;= 3 and order = 1.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array\n    scale_factor: AxesParams\n        float or sequence of floats describing how to scale along axes\n    axis: AxesLike\n        axis along which array will be scaled\n    order: int\n        order of interpolation\n    fill_value: float | Callable\n        value to fill past edges. If Callable (e.g. `numpy.min`) - `fill_value(x)` will be used\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `numba`, `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    zoomed: np.ndarray\n        zoomed array\n    Examples\n    --------\n    &gt;&gt;&gt; zoomed = zoom(x, 2, axis=[0, 1])  # 3d array\n    &gt;&gt;&gt; zoomed = zoom(x, [1, 2, 3])  # different scales along each axes\n    &gt;&gt;&gt; zoomed = zoom(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n    \"\"\"\nx = np.asarray(x)\naxis, scale_factor = broadcast_axis(axis, x.ndim, scale_factor)\nscale_factor = fill_by_indices(np.ones(x.ndim, 'float64'), scale_factor, axis)\nif callable(fill_value):\nfill_value = fill_value(x)\nreturn _zoom(x, scale_factor, order=order, cval=fill_value, num_threads=num_threads, backend=backend)\n</code></pre>"},{"location":"#imops.zoom.zoom_to_shape","title":"<code>imops.zoom.zoom_to_shape(x, shape, axis=None, order=1, fill_value=0, num_threads=-1, backend=None)</code>","text":"<p>Rescale <code>x</code> to match <code>shape</code> along the <code>axis</code>.</p> <p>Uses a fast parallelizable implementation for fp32 / fp64 inputs, ndim &lt;= 3 and order = 1.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>n-dimensional array</p> required <code>shape</code> <code>AxesLike</code> <p>float or sequence of floats describing desired lengths along axes</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which array will be scaled</p> <code>None</code> <code>order</code> <code>int</code> <p>order of interpolation</p> <code>1</code> <code>fill_value</code> <code>Union[float, Callable]</code> <p>value to fill past edges. If Callable (e.g. <code>numpy.min</code>) - <code>fill_value(x)</code> will be used</p> <code>0</code> <code>num_threads</code> <code>int</code> <p>the number of threads to use for computation. Default = the cpu count. If negative value passed cpu count + num_threads + 1 threads will be used</p> <code>-1</code> <code>backend</code> <code>BackendLike</code> <p>which backend to use. <code>numba</code>, <code>cython</code> and <code>scipy</code> are available, <code>cython</code> is used by default</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zoomed</code> <code>np.ndarray</code> <p>zoomed array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; zoomed = zoom_to_shape(x, [3, 4, 5])  # 3d array\n&gt;&gt;&gt; zoomed = zoom_to_shape(x, [6, 7], axis=[1, 2])  # zoom to shape along specified axes\n&gt;&gt;&gt; zoomed = zoom_to_shape(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n</code></pre> Source code in <code>imops/zoom.py</code> <pre><code>def zoom_to_shape(\nx: np.ndarray,\nshape: AxesLike,\naxis: AxesLike = None,\norder: int = 1,\nfill_value: Union[float, Callable] = 0,\nnum_threads: int = -1,\nbackend: BackendLike = None,\n) -&gt; np.ndarray:\n\"\"\"\n    Rescale `x` to match `shape` along the `axis`.\n    Uses a fast parallelizable implementation for fp32 / fp64 inputs, ndim &lt;= 3 and order = 1.\n    Parameters\n    ----------\n    x: np.ndarray\n        n-dimensional array\n    shape: AxesLike\n        float or sequence of floats describing desired lengths along axes\n    axis: AxesLike\n        axis along which array will be scaled\n    order: int\n        order of interpolation\n    fill_value: float | Callable\n        value to fill past edges. If Callable (e.g. `numpy.min`) - `fill_value(x)` will be used\n    num_threads: int\n        the number of threads to use for computation. Default = the cpu count. If negative value passed\n        cpu count + num_threads + 1 threads will be used\n    backend: BackendLike\n        which backend to use. `numba`, `cython` and `scipy` are available, `cython` is used by default\n    Returns\n    -------\n    zoomed: np.ndarray\n        zoomed array\n    Examples\n    --------\n    &gt;&gt;&gt; zoomed = zoom_to_shape(x, [3, 4, 5])  # 3d array\n    &gt;&gt;&gt; zoomed = zoom_to_shape(x, [6, 7], axis=[1, 2])  # zoom to shape along specified axes\n    &gt;&gt;&gt; zoomed = zoom_to_shape(x.astype(int))  # will fall back to scipy's implementation because of int dtype\n    \"\"\"\nx = np.asarray(x)\naxis, shape = broadcast_axis(axis, x.ndim, shape)\nold_shape = np.array(x.shape, 'float64')\nnew_shape = np.array(fill_by_indices(x.shape, shape, axis), 'float64')\nreturn zoom(\nx,\nnew_shape / old_shape,\nrange(x.ndim),\norder=order,\nfill_value=fill_value,\nnum_threads=num_threads,\nbackend=backend,\n)\n</code></pre>"},{"location":"#imops.pad.pad","title":"<code>imops.pad.pad(x, padding, axis=None, padding_values=0)</code>","text":"<p>Pad <code>x</code> according to <code>padding</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>array to pad</p> required <code>padding</code> <code>Union[AxesLike, Sequence[Sequence[int]]]</code> <p>if 2D array [[start_1, stop_1], ..., [start_n, stop_n]] - specifies individual padding for each axis from <code>axis</code>. The length of the array must either be equal to 1 or match the length of <code>axis</code>. If 1D array [val_1, ..., val_n] - same as [[val_1, val_1], ..., [val_n, val_n]]. If scalar (val) - same as [[val, val]]</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with, must be broadcastable to the resulting array. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; padded = pad(x, 2)  # pad 2 zeros on each side of each axes\n&gt;&gt;&gt; padded = pad(x, [1, 1], axis=(-1, -2))  # pad 1 zero on each side of last 2 axes\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def pad(\nx: np.ndarray,\npadding: Union[AxesLike, Sequence[Sequence[int]]],\naxis: AxesLike = None,\npadding_values: Union[AxesParams, Callable] = 0,\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` according to `padding` along the `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        array to pad\n    padding: Union[AxesLike, Sequence[Sequence[int]]]\n        if 2D array [[start_1, stop_1], ..., [start_n, stop_n]] - specifies individual padding\n        for each axis from `axis`. The length of the array must either be equal to 1 or match the length of `axis`.\n        If 1D array [val_1, ..., val_n] - same as [[val_1, val_1], ..., [val_n, val_n]].\n        If scalar (val) - same as [[val, val]]\n    axis: AxesLike\n        axis along which `x` will be padded\n    padding_values: Union[AxesParams, Callable]\n        values to pad with, must be broadcastable to the resulting array.\n        If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; padded = pad(x, 2)  # pad 2 zeros on each side of each axes\n    &gt;&gt;&gt; padded = pad(x, [1, 1], axis=(-1, -2))  # pad 1 zero on each side of last 2 axes\n    \"\"\"\nx = np.asarray(x)\npadding = np.asarray(padding)\nif padding.ndim &lt; 2:\npadding = padding.reshape(-1, 1)\naxis = axis_from_dim(axis, x.ndim)\npadding = np.asarray(fill_by_indices(np.zeros((x.ndim, 2), dtype=int), np.atleast_2d(padding), axis))\nif (padding &lt; 0).any():\nraise ValueError(f'Padding must be non-negative: {padding.tolist()}.')\nif callable(padding_values):\npadding_values = padding_values(x)\nnew_shape = np.array(x.shape) + np.sum(padding, axis=1)\nnew_x = np.array(padding_values, dtype=x.dtype)\nnew_x = np.broadcast_to(new_x, new_shape).copy()\nstart = padding[:, 0]\nend = np.where(padding[:, 1] != 0, -padding[:, 1], None)\nnew_x[tuple(map(slice, start, end))] = x\nreturn new_x\n</code></pre>"},{"location":"#imops.pad.pad_to_shape","title":"<code>imops.pad.pad_to_shape(x, shape, axis=None, padding_values=0, ratio=0.5)</code>","text":"<p>Pad <code>x</code> to match <code>shape</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>array to pad</p> required <code>shape</code> <code>AxesLike</code> <p>final shape</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which <code>x</code> will be padded</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with, must be broadcastable to the resulting array. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes. Remaining ratio of padding will be applied on the right sides</p> <code>0.5</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; padded = pad_to_shape(x, [4, 5, 6])  # pad 3d array\n&gt;&gt;&gt; padded = pad_to_shape(x, [4, 5], axis=[0, 1], ratio=0)  # pad first 2 axes on the right\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def pad_to_shape(\nx: np.ndarray,\nshape: AxesLike,\naxis: AxesLike = None,\npadding_values: Union[AxesParams, Callable] = 0,\nratio: AxesParams = 0.5,\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` to match `shape` along the `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        array to pad\n    shape: AxesLike\n        final shape\n    axis: AxesLike\n        axis along which `x` will be padded\n    padding_values: Union[AxesParams, Callable]\n        values to pad with, must be broadcastable to the resulting array.\n        If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    ratio: AxesParams\n        float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes.\n        Remaining ratio of padding will be applied on the right sides\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; padded = pad_to_shape(x, [4, 5, 6])  # pad 3d array\n    &gt;&gt;&gt; padded = pad_to_shape(x, [4, 5], axis=[0, 1], ratio=0)  # pad first 2 axes on the right\n    \"\"\"\nx = np.asarray(x)\naxis, shape, ratio = broadcast_axis(axis, x.ndim, shape, ratio)\nold_shape = np.array(x.shape)[list(axis)]\nif (old_shape &gt; shape).any():\nshape = fill_by_indices(x.shape, shape, axis)\nraise ValueError(f'The resulting shape cannot be smaller than the original: {x.shape} vs {shape}.')\ndelta = shape - old_shape\nstart = (delta * ratio).astype(int)\npadding = np.array((start, delta - start)).T.astype(int)\nreturn pad(x, padding, axis, padding_values=padding_values)\n</code></pre>"},{"location":"#imops.pad.pad_to_divisible","title":"<code>imops.pad.pad_to_divisible(x, divisor, axis=None, padding_values=0, ratio=0.5, remainder=0)</code>","text":"<p>Pad <code>x</code> to be divisible by <code>divisor</code> along the <code>axis</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>array to pad</p> required <code>divisor</code> <code>AxesLike</code> <p>float or sequence of floats an incoming array shape will be divisible by</p> required <code>axis</code> <code>AxesLike</code> <p>axis along which the array will be padded. If None - the last <code>len(divisor)</code> axes are used</p> <code>None</code> <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <code>ratio</code> <code>AxesParams</code> <p>float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes. Remaining ratio of padding will be applied on the right sides</p> <code>0.5</code> <code>remainder</code> <code>AxesLike</code> <p><code>x</code> will be padded such that its shape gives the remainder <code>remainder</code> when divided by <code>divisor</code></p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; padded = pad_to_divisible(x, 6)  # pad to shape [6, 6, 6]\n&gt;&gt;&gt; padded = pad_to_divisible(x, [4, 3], axis=[0, 1], ratio=1)  # pad first 2 axes on the left, shape - [4, 3, 4]\n&gt;&gt;&gt; padded = pad_to_divisible(x, 3, remainder=1)  # pad to shape [4, 4, 4]\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def pad_to_divisible(\nx: np.ndarray,\ndivisor: AxesLike,\naxis: AxesLike = None,\npadding_values: Union[AxesParams, Callable] = 0,\nratio: AxesParams = 0.5,\nremainder: AxesLike = 0,\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` to be divisible by `divisor` along the `axis`.\n    Parameters\n    ----------\n    x: np.ndarray\n        array to pad\n    divisor: AxesLike\n        float or sequence of floats an incoming array shape will be divisible by\n    axis: AxesLike\n        axis along which the array will be padded. If None - the last `len(divisor)` axes are used\n    padding_values: Union[AxesParams, Callable]\n        values to pad with. If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    ratio: AxesParams\n        float or sequence of floats describing what proportion of padding to apply on the left sides of padding axes.\n        Remaining ratio of padding will be applied on the right sides\n    remainder: AxesLike\n        `x` will be padded such that its shape gives the remainder `remainder` when divided by `divisor`\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; x  # array of shape [2, 3, 4]\n    &gt;&gt;&gt; padded = pad_to_divisible(x, 6)  # pad to shape [6, 6, 6]\n    &gt;&gt;&gt; padded = pad_to_divisible(x, [4, 3], axis=[0, 1], ratio=1)  # pad first 2 axes on the left, shape - [4, 3, 4]\n    &gt;&gt;&gt; padded = pad_to_divisible(x, 3, remainder=1)  # pad to shape [4, 4, 4]\n    \"\"\"\nx = np.asarray(x)\naxis = axis_from_dim(axis, x.ndim)\ndivisor, remainder, ratio = broadcast_to_axis(axis, divisor, remainder, ratio)\nassert np.all(remainder &gt;= 0)\nshape = np.maximum(np.array(x.shape)[list(axis)], remainder)\nreturn pad_to_shape(x, shape + (remainder - shape) % divisor, axis, padding_values, ratio)\n</code></pre>"},{"location":"#imops.pad.restore_crop","title":"<code>imops.pad.restore_crop(x, box, shape, padding_values=0)</code>","text":"<p>Pad <code>x</code> to match <code>shape</code>. The left padding is taken equal to <code>box</code>'s start.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>np.ndarray</code> <p>array to pad</p> required <code>box</code> <code>np.ndarray</code> <p>array of shape (2, x.ndim) describing crop boundaries</p> required <code>shape</code> <code>AxesLike</code> <p>shape to restore crop to</p> required <code>padding_values</code> <code>Union[AxesParams, Callable]</code> <p>values to pad with. If Callable (e.g. <code>numpy.min</code>) - <code>padding_values(x)</code> will be used</p> <code>0</code> <p>Returns:</p> Name Type Description <code>padded</code> <code>np.ndarray</code> <p>padded array</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x  # array of shape [2, 3, 4]\n&gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [2, 3, 4]]), [4, 4, 4])  # pad to shape [4, 4, 4]\n&gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [1, 1, 1]]), [4, 4, 4])  # fail, box is inconsistent with an array\n&gt;&gt;&gt; padded = restore_crop(x, np.array([[1, 2, 3], [3, 5, 7]]), [3, 5, 7])  # pad to shape [3, 5, 7]\n</code></pre> Source code in <code>imops/pad.py</code> <pre><code>def restore_crop(\nx: np.ndarray, box: np.ndarray, shape: AxesLike, padding_values: Union[AxesParams, Callable] = 0\n) -&gt; np.ndarray:\n\"\"\"\n    Pad `x` to match `shape`. The left padding is taken equal to `box`'s start.\n    Parameters\n    ----------\n    x: np.ndarray\n        array to pad\n    box: np.ndarray\n        array of shape (2, x.ndim) describing crop boundaries\n    shape: AxesLike\n        shape to restore crop to\n    padding_values: Union[AxesParams, Callable]\n        values to pad with. If Callable (e.g. `numpy.min`) - `padding_values(x)` will be used\n    Returns\n    -------\n    padded: np.ndarray\n        padded array\n    Examples\n    --------\n    &gt;&gt;&gt; x  # array of shape [2, 3, 4]\n    &gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [2, 3, 4]]), [4, 4, 4])  # pad to shape [4, 4, 4]\n    &gt;&gt;&gt; padded = restore_crop(x, np.array([[0, 0, 0], [1, 1, 1]]), [4, 4, 4])  # fail, box is inconsistent with an array\n    &gt;&gt;&gt; padded = restore_crop(x, np.array([[1, 2, 3], [3, 5, 7]]), [3, 5, 7])  # pad to shape [3, 5, 7]\n    \"\"\"\nstart, stop = np.asarray(box)\nassert len(shape) == x.ndim\nassert len(start) == len(stop) == x.ndim\nx = np.asarray(x)\nif (stop &gt; shape).any() or (stop - start != x.shape).any():\nraise ValueError(\nf'The input array (of shape {x.shape}) was not obtained by cropping a '\nf'box {start, stop} from the shape {shape}.'\n)\npadding = np.array([start, shape - stop], dtype=int).T\nx = pad(x, padding, padding_values=padding_values)\nassert all(np.array(x.shape) == shape)\nreturn x\n</code></pre>"}]}